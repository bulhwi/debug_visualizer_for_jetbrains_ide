# 제품 요구사항 정의서 (PRD)
# Algorithm Debug Visualizer for JetBrains IDEs

**버전**: 1.0.0
**작성일**: 2024-11-10
**상태**: 초안

---

## 1. 개요

### 1.1 제품 비전

Algorithm Debug Visualizer는 JetBrains IDE 사용자들이 알고리즘과 데이터 구조를 **시각적으로 이해**하고 디버깅할 수 있도록 돕는 혁신적인 플러그인입니다. 복잡한 알고리즘의 실행 과정을 실시간으로 시각화하여, 학습과 개발 생산성을 극대화합니다.

### 1.2 목표

- **학습 효율성 향상**: 알고리즘 학습자가 코드 실행 과정을 직관적으로 이해
- **디버깅 생산성 향상**: 복잡한 데이터 구조의 상태를 빠르게 파악
- **교육 지원**: 교육자가 알고리즘을 효과적으로 설명할 수 있는 도구 제공
- **생태계 확장**: JetBrains 생태계에 VSCode Debug Visualizer 수준의 도구 제공

### 1.3 성공 지표

| 지표 | 목표 | 측정 방법 |
|------|------|-----------|
| 다운로드 수 | 첫 6개월 내 10,000+ | JetBrains Marketplace |
| 활성 사용자 | 월 1,000+ | 텔레메트리 (옵트인) |
| 사용자 평점 | 4.0+ / 5.0 | JetBrains Marketplace |
| 커뮤니티 기여 | 5+ 외부 기여자 | GitHub Contributors |
| 버그 해결률 | Critical 버그 48시간 이내 | GitHub Issues |

---

## 2. 사용자 페르소나

### 페르소나 1: 알고리즘 학습자 "지민"

- **나이**: 23세, 컴퓨터과학 전공 대학생
- **목표**: 코딩 테스트 준비, 알고리즘 개념 이해
- **고충**:
  - 트리 순회 같은 재귀 알고리즘이 어떻게 동작하는지 이해 어려움
  - 디버거로 한 줄씩 따라가도 전체 흐름 파악 힘듦
  - DP 테이블이 어떻게 채워지는지 시각적으로 보고 싶음
- **니즈**: 실행 과정을 애니메이션으로 보고 싶음

### 페르소나 2: 백엔드 엔지니어 "서연"

- **나이**: 29세, 5년차 백엔드 개발자
- **목표**: 복잡한 비즈니스 로직 디버깅, 성능 최적화
- **고충**:
  - 복잡한 그래프 구조의 상태를 디버거에서 추적하기 어려움
  - 대용량 배열의 변화 패턴을 빠르게 파악하고 싶음
  - 중첩된 자료구조를 텍스트로 보는 것이 비효율적
- **니즈**: 실시간으로 데이터 구조의 변화를 시각적으로 추적

### 페르소나 3: 알고리즘 강사 "현수"

- **나이**: 35세, 알고리즘 온라인 강의 진행
- **목표**: 학생들에게 알고리즘을 효과적으로 설명
- **고충**:
  - 파워포인트나 화이트보드만으로는 동적인 과정 설명 한계
  - 실제 코드 실행을 라이브로 보여주고 싶지만 디버거는 교육용으로 부적합
  - 각 단계를 천천히 보여주며 설명하고 싶음
- **니즈**: 코드 실행을 단계별로 보여주며 설명할 수 있는 도구

---

## 3. 기능 요구사항

### 3.1 핵심 기능 (MVP)

#### F1. 디버거 통합
**우선순위**: P0 (필수)
**설명**: JetBrains IDE 디버거와 긴밀하게 통합되어 디버깅 세션 중 데이터 시각화

**요구사항**:
- [ ] 디버거 중단점에서 자동으로 활성화
- [ ] 현재 스택 프레임의 변수에 접근
- [ ] 표현식 평가 (예: `myTree.root`)
- [ ] 스텝 실행 시 자동 업데이트

**수용 기준**:
- 디버거 중단 시 1초 이내 시각화 표시
- 표현식 평가 성공률 95% 이상
- 스텝 실행 시 즉시 반영

#### F2. 기본 시각화 타입
**우선순위**: P0 (필수)
**설명**: 가장 많이 사용되는 데이터 구조의 시각화

**요구사항**:
- [ ] 배열 시각화 (막대 그래프, 인덱스 표시)
- [ ] 이진 트리 시각화 (계층적 레이아웃)
- [ ] 그래프 시각화 (노드-엣지 다이어그램)
- [ ] 테이블 시각화 (2D 배열, DP 테이블)

**수용 기준**:
- 각 타입별 1000개 요소까지 1초 이내 렌더링
- 모바일 반응형 지원 불필요 (IDE 환경)
- 줌/팬 인터랙션 지원

#### F3. 언어 지원 (Tier 1)
**우선순위**: P0 (필수)
**설명**: 자동 데이터 추출을 지원하는 주요 언어

**요구사항**:
- [ ] Java: JDI를 통한 객체 필드 접근
- [ ] Kotlin: Java와 동일한 메커니즘
- [ ] Python: debugpy 프로토콜 연동
- [ ] JavaScript/TypeScript: Chrome DevTools 프로토콜

**수용 기준**:
- 각 언어에서 기본 자료구조 (배열, 리스트, 맵) 자동 감지
- 커스텀 클래스 (TreeNode, Graph 등) 지원
- 타입 감지 정확도 90% 이상

#### F4. 도구 윈도우
**우선순위**: P0 (필수)
**설명**: IDE 내 전용 도구 윈도우에서 시각화 표시

**요구사항**:
- [ ] IDE 하단 또는 측면에 도킹 가능
- [ ] 표현식 입력 필드
- [ ] 시각화 렌더링 영역
- [ ] 컨트롤 패널 (새로고침, 설정 등)

**수용 기준**:
- IDE 기본 테마와 일관된 UI
- 창 크기 조절 시 시각화 자동 리사이즈
- 다중 탭 지원 (여러 시각화 동시 열기)

### 3.2 고급 기능 (Post-MVP)

#### F5. 알고리즘별 최적화 시각화
**우선순위**: P1 (중요)
**설명**: 특정 알고리즘에 특화된 시각화 제공

**요구사항**:
- [ ] 정렬 알고리즘: 비교/교환 하이라이트
- [ ] 그래프 탐색: 방문 순서, 경로 표시
- [ ] DP: 셀 채워지는 순서, 의존성 표시
- [ ] 백트래킹: 결정 트리, 가지치기 표시

#### F6. 애니메이션 재생
**우선순위**: P1 (중요)
**설명**: 알고리즘 실행 과정을 단계별로 재생

**요구사항**:
- [ ] 실행 히스토리 기록
- [ ] 재생/일시정지/이전/다음 컨트롤
- [ ] 재생 속도 조절 (0.5x ~ 2x)
- [ ] 특정 단계로 점프

#### F7. 커스텀 시각화 API
**우선순위**: P2 (선택)
**설명**: 사용자가 자신의 데이터 구조에 대한 시각화 정의

**요구사항**:
- [ ] Extension Point 제공
- [ ] JSON 스키마 기반 정의
- [ ] 샘플 커스텀 시각화 제공
- [ ] 문서 및 튜토리얼

#### F8. 내보내기
**우선순위**: P2 (선택)
**설명**: 시각화를 이미지/비디오로 저장

**요구사항**:
- [ ] PNG/SVG 이미지 내보내기
- [ ] 애니메이션 GIF 생성
- [ ] 클립보드 복사
- [ ] 보고서용 HTML 생성

### 3.3 기능 우선순위 매트릭스

| 기능 | 사용자 가치 | 개발 난이도 | 우선순위 |
|------|------------|------------|---------|
| F1. 디버거 통합 | 높음 | 높음 | P0 |
| F2. 기본 시각화 | 높음 | 중간 | P0 |
| F3. 언어 지원 | 높음 | 높음 | P0 |
| F4. 도구 윈도우 | 높음 | 낮음 | P0 |
| F5. 알고리즘 최적화 | 중간 | 중간 | P1 |
| F6. 애니메이션 | 중간 | 높음 | P1 |
| F7. 커스텀 API | 낮음 | 중간 | P2 |
| F8. 내보내기 | 낮음 | 낮음 | P2 |

---

## 4. 비기능 요구사항

### 4.1 성능

| 요구사항 | 목표 | 측정 방법 |
|---------|------|-----------|
| 시각화 렌더링 시간 | < 1초 (1000개 요소) | 성능 벤치마크 |
| 메모리 사용량 | < 200MB | Profiler |
| IDE 반응성 영향 | < 5% | 벤치마크 비교 |
| 디버거 스텝 지연 | < 100ms | 타이머 측정 |

### 4.2 사용성

- **학습 곡선**: 첫 사용 후 5분 내 기본 기능 사용 가능
- **오류 메시지**: 명확하고 해결 방법 제시
- **문서**: 각 시각화 타입별 예제 제공
- **접근성**: 키보드 네비게이션 지원

### 4.3 호환성

| 카테고리 | 요구사항 |
|---------|---------|
| IDE 버전 | IntelliJ IDEA 2023.1+ |
| JDK | 17+ |
| OS | Windows 10+, macOS 11+, Linux (Ubuntu 20.04+) |
| 화면 해상도 | 최소 1280x720 |

### 4.4 확장성

- **새로운 시각화 타입**: 플러그인 아키텍처로 쉽게 추가
- **새로운 언어**: Extension Point로 지원 추가
- **커스터마이징**: 테마, 레이아웃 설정 가능

### 4.5 보안

- **코드 실행**: 디버거 컨텍스트 내에서만 실행, 임의 코드 실행 불가
- **데이터 전송**: 로컬에서만 동작, 외부 서버 전송 없음
- **텔레메트리**: 옵트인 방식, 개인정보 미수집

### 4.6 안정성

- **크래시율**: < 0.1% (세션당)
- **오류 복구**: 시각화 오류 시 IDE 전체 영향 없음
- **버그 심각도**: Critical 버그 0개 유지

---

## 5. 사용자 스토리

### 5.1 학습자 스토리

**US-1**: 트리 순회 이해하기
```
As a 알고리즘 학습자
I want to 이진 트리의 중위 순회 과정을 시각적으로 보고 싶다
So that 재귀 호출 순서를 직관적으로 이해할 수 있다

수용 기준:
- 중단점을 설정하고 스텝 실행 시 현재 방문 노드가 하이라이트됨
- 방문 순서가 숫자로 표시됨
- 스택 프레임이 트리와 함께 표시됨
```

**US-2**: DP 테이블 채워지는 과정 보기
```
As a 알고리즘 학습자
I want to DP 테이블이 어떤 순서로 채워지는지 보고 싶다
So that 점화식의 동작 원리를 이해할 수 있다

수용 기준:
- 2D 테이블로 dp 배열 표시
- 각 셀의 값과 색상으로 계산 여부 표시
- 현재 계산 중인 셀 하이라이트
```

### 5.2 개발자 스토리

**US-3**: 그래프 알고리즘 디버깅
```
As a 백엔드 엔지니어
I want to 다익스트라 알고리즘 실행 중 그래프 상태를 보고 싶다
So that 버그를 빠르게 찾을 수 있다

수용 기준:
- 노드와 엣지가 그래프로 표시됨
- 현재 탐색 중인 노드가 색상으로 구분됨
- 각 노드의 거리 값이 표시됨
- 확정된 경로가 강조됨
```

**US-4**: 복잡한 배열 상태 확인
```
As a 백엔드 엔지니어
I want to 정렬 알고리즘 실행 중 배열 상태를 막대 그래프로 보고 싶다
So that 비교/교환 과정을 시각적으로 추적할 수 있다

수용 기준:
- 배열 요소가 막대 그래프로 표시됨
- 현재 비교 중인 요소가 하이라이트됨
- 포인터 위치가 표시됨
```

### 5.3 교육자 스토리

**US-5**: 강의 중 알고리즘 시연
```
As a 알고리즘 강사
I want to 학생들에게 BFS 알고리즘을 단계별로 시연하고 싶다
So that 알고리즘 동작 원리를 효과적으로 설명할 수 있다

수용 기준:
- 실행 히스토리를 저장하여 앞뒤로 이동 가능
- 재생 속도 조절 가능
- 특정 단계에서 일시정지하고 설명 가능
- 시각화를 이미지로 내보내기 가능
```

---

## 6. 기술 요구사항

### 6.1 기술 스택

**플러그인:**
- Kotlin (언어)
- IntelliJ Platform SDK 2023.1+ (프레임워크)
- Gradle 8.0+ (빌드)
- JUnit 5 (테스트)

**UI:**
- TypeScript (언어)
- React 18+ (프레임워크)
- D3.js 7+ (그래프/트리 시각화)
- Plotly.js (차트)
- Cytoscape.js (복잡한 네트워크)
- Vite (번들러)
- Jest + React Testing Library (테스트)

**통신:**
- JCEF (Java Chromium Embedded Framework)
- CEF JavaScript Bridge

### 6.2 아키텍처 제약사항

- **플러그인 격리**: 플러그인 오류가 IDE 전체에 영향을 주지 않도록 격리
- **스레드 안전**: 디버거 이벤트는 별도 스레드에서 처리
- **메모리 제한**: 시각화 데이터는 WeakReference 사용하여 메모리 누수 방지
- **샌드박스**: WebView는 격리된 컨텍스트에서 실행

### 6.3 데이터 스키마

시각화 데이터는 JSON 형식으로 정의:
```json
{
  "kind": "graph" | "tree" | "array" | "table" | "plotly" | "grid",
  "timestamp": 1234567890,
  "metadata": {
    "language": "java",
    "expression": "myTree",
    "type": "TreeNode"
  },
  "data": { /* kind별 데이터 */ },
  "config": { /* 시각화 설정 */ }
}
```

상세 스키마: `docs/visualization-schema.md` 참조

---

## 7. 사용자 인터페이스

### 7.1 주요 화면

#### 도구 윈도우
```
┌─────────────────────────────────────────────┐
│ Algorithm Visualizer                    [⚙️][✕]│
├─────────────────────────────────────────────┤
│ Expression: myTree.root            [▶️ Eval] │
├─────────────────────────────────────────────┤
│                                             │
│         [Visualization Area]                │
│                                             │
│          🌳 Tree Visualization              │
│                                             │
│               10                            │
│              /  \                           │
│             5    15                         │
│            / \   / \                        │
│           3   7 12  20                      │
│                                             │
├─────────────────────────────────────────────┤
│ [⬅️][▶️][⏸️] Speed: 1x  [Export] [Settings]  │
└─────────────────────────────────────────────┘
```

### 7.2 인터랙션 플로우

1. **초기 설정**
   - 사용자가 JetBrains IDE 설치
   - Marketplace에서 "Algorithm Visualizer" 검색 및 설치
   - IDE 재시작

2. **디버깅 시작**
   - 사용자가 코드에 중단점 설정
   - 디버그 모드로 실행
   - 중단점에 도달

3. **시각화 표시**
   - 도구 윈도우 자동 활성화
   - 표현식 입력 필드에 변수명 입력 (예: `myTree`)
   - "Eval" 버튼 클릭 또는 Enter
   - 시각화 자동 렌더링

4. **스테핑 및 업데이트**
   - 사용자가 "Step Over" 실행
   - 시각화 자동 업데이트
   - 변경된 부분 하이라이트

### 7.3 와이어프레임

상세 와이어프레임은 Figma 링크 참조: (TBD)

---

## 8. 제약사항 및 가정

### 8.1 제약사항

1. **플랫폼 제약**
   - JetBrains IDE에서만 동작 (VSCode, Eclipse 지원 안 함)
   - JCEF를 지원하는 IDE 버전만 사용 가능

2. **성능 제약**
   - 매우 큰 데이터 구조 (10,000+ 요소)는 페이지네이션 필요
   - 실시간 애니메이션은 CPU 사용량 증가

3. **언어 제약**
   - 각 언어별 디버거 프로토콜에 의존
   - 일부 언어는 제한적 지원 (C++, Go 등)

4. **보안 제약**
   - 임의 코드 실행 불가, 디버거 컨텍스트만 사용
   - 외부 네트워크 통신 없음

### 8.2 가정

1. **사용자 환경**
   - 사용자는 기본적인 디버거 사용법을 알고 있음
   - 충분한 메모리와 CPU를 가진 개발 환경

2. **데이터 구조**
   - 사용자의 데이터 구조는 표준적인 패턴을 따름
   - 순환 참조가 있는 경우 적절히 처리됨

3. **IDE 호환성**
   - IntelliJ Platform API는 하위 호환성 유지
   - JCEF는 계속 지원됨

---

## 9. 개발 로드맵

### Phase 0: 기획 및 설계 (2주) ✅
- [x] PRD 작성
- [x] 아키텍처 설계
- [x] UI/UX 디자인
- [x] 기술 스택 결정

### Phase 1: MVP 개발 (8주)
**Week 1-2: 플러그인 인프라**
- [ ] 플러그인 프로젝트 초기화
- [ ] 도구 윈도우 생성
- [ ] 디버거 API 통합
- [ ] 표현식 평가 기본 구현

**Week 3-4: 시각화 엔진**
- [ ] React 프로젝트 초기화
- [ ] JCEF 통합
- [ ] 기본 렌더러 (배열, 트리)
- [ ] JSON 브리지 구축

**Week 5-6: 언어 지원**
- [ ] Java/Kotlin 데이터 추출기
- [ ] Python 데이터 추출기
- [ ] 타입 감지 로직

**Week 7-8: 통합 및 테스트**
- [ ] 전체 플로우 통합
- [ ] 샘플 프로젝트 테스트
- [ ] 버그 수정
- [ ] 문서 작성

### Phase 2: 고급 기능 (6주)
- [ ] 그래프 알고리즘 시각화
- [ ] DP 테이블 시각화
- [ ] JavaScript/TypeScript 지원
- [ ] 애니메이션 기본 구현

### Phase 3: 폴리싱 (4주)
- [ ] 성능 최적화
- [ ] UI/UX 개선
- [ ] 추가 테스트
- [ ] 베타 릴리스

### Phase 4: 정식 출시 (2주)
- [ ] 최종 버그 수정
- [ ] 문서 완성
- [ ] JetBrains Marketplace 등록
- [ ] 마케팅 및 홍보

---

## 10. 위험 관리

| 위험 | 확률 | 영향 | 대응 전략 |
|------|------|------|-----------|
| IntelliJ Platform API 변경 | 중간 | 높음 | 안정 버전 API 사용, 변경 모니터링 |
| 성능 문제 | 높음 | 중간 | 초기부터 벤치마크, 최적화 우선순위 |
| 언어별 디버거 호환성 | 높음 | 높음 | Tier 시스템으로 점진적 지원 |
| 사용자 채택 저조 | 중간 | 높음 | 베타 테스트, 사용자 피드백 반영 |
| 보안 취약점 | 낮음 | 높음 | 코드 리뷰, 보안 감사 |

---

## 11. 출시 전략

### 11.1 베타 테스트
- **기간**: 정식 출시 4주 전
- **참여자**: 50명 (학생, 개발자, 강사)
- **피드백 수집**: 설문조사, 인터뷰, 텔레메트리

### 11.2 마케팅
- GitHub README 및 문서 완성
- JetBrains Marketplace 등록
- Reddit, HackerNews 포스팅
- 유튜브 데모 영상
- 블로그 포스트

### 11.3 지원 채널
- GitHub Issues (버그 리포트)
- GitHub Discussions (질문, 토론)
- 이메일 (중요 문의)

---

## 12. 측정 및 분석

### 12.1 주요 메트릭

**사용량 메트릭** (옵트인):
- DAU/MAU (일간/월간 활성 사용자)
- 세션당 평균 시각화 수
- 가장 많이 사용되는 시각화 타입
- 평균 세션 길이

**품질 메트릭**:
- 크래시율
- 오류 발생 빈도
- 응답 시간 (P50, P95, P99)

**비즈니스 메트릭**:
- 다운로드 수 (누적, 주간)
- 사용자 평점 및 리뷰
- 커뮤니티 활동 (이슈, PR, 포럼)

### 12.2 A/B 테스트 계획
- UI 레이아웃 (좌측 vs 하단 도구 윈도우)
- 기본 시각화 타입 선택 로직
- 애니메이션 기본 속도

---

## 13. 부록

### 13.1 용어 정의

- **시각화**: 데이터 구조를 그래픽으로 표현한 것
- **렌더러**: 특정 시각화 타입을 그리는 컴포넌트
- **추출기**: 디버거에서 데이터를 JSON으로 변환하는 모듈
- **도구 윈도우**: IDE 내 독립적인 UI 패널

### 13.2 참고 자료

- [IntelliJ Platform SDK 문서](https://plugins.jetbrains.com/docs/intellij/)
- [VSCode Debug Visualizer GitHub](https://github.com/hediet/vscode-debug-visualizer)
- [D3.js 예제](https://observablehq.com/@d3/gallery)

### 13.3 변경 이력

| 버전 | 날짜 | 변경 내용 | 작성자 |
|------|------|-----------|--------|
| 1.0.0 | 2024-11-10 | 초안 작성 | - |

---

**승인자**: TBD
**다음 리뷰 예정일**: TBD
